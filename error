public static void findDateByFormats(String text, String inputDateStr, Map<String, List<PdfMetaData>> metadata, int page) {
    LocalDate inputDate = parseToDate(inputDateStr);
    if (inputDate == null) return;

    List<String> formattedVariants = formatDateVariants(inputDate);

    for (String variant : formattedVariants) {
        if (text.toLowerCase().contains(variant.toLowerCase())) {
            addToMetadataList(metadata, inputDateStr, page);
            break;
        }
    }
}

// Step 1: Parse input string to LocalDate using multiple formats
private static LocalDate parseToDate(String dateStr) {
    String[] formats = {
        "yyyy-MM-dd", "MM/dd/yyyy", "dd/MM/yyyy", "dd-MM-yyyy", 
        "MMM dd, yyyy", "dd MMM yyyy", "MMMM dd, yyyy", 
        "yyyy/MM/dd", "M/d/yyyy", "d MMM yyyy", "d MMMM yyyy"
    };

    for (String fmt : formats) {
        try {
            return LocalDate.parse(dateStr, DateTimeFormatter.ofPattern(fmt, Locale.ENGLISH));
        } catch (DateTimeParseException e) {
            // Try next
        }
    }
    return null;
}

// Step 2: Generate all common format variations of a date
private static List<String> formatDateVariants(LocalDate date) {
    String[] outputFormats = {
        "yyyy-MM-dd", "MM/dd/yyyy", "dd/MM/yyyy", "dd-MM-yyyy", 
        "MMM dd, yyyy", "dd MMM yyyy", "MMMM dd, yyyy", 
        "yyyy/MM/dd", "M/d/yyyy", "d MMM yyyy", "d MMMM yyyy"
    };

    List<String> variants = new ArrayList<>();
    for (String fmt : outputFormats) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(fmt, Locale.ENGLISH);
        variants.add(date.format(formatter));
    }
    return variants;
}
