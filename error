public ResponseEntity<byte[]> processPdfTest(PdfDocument pdfDocument) {
    String pdfName = pdfDocument.getPdfName(); // Get the PDF name from the PdfDocument object
    logger.info("Received request to process PDF: {}", pdfName);

    try {
        byte[] pdfBytes = new byte[0];
        if (Boolean.parseBoolean(useLocal)) {
            // Use pdfName to locate the PDF file
            File sourceFile = new File(localDirectory, pdfName);
            if (!sourceFile.exists()) {
                logger.error("Local PDF not found: {}", sourceFile.getAbsolutePath());
                return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            }
            logger.info("Loading PDF from local path: {}", sourceFile.getAbsolutePath());
            pdfBytes = Files.readAllBytes(sourceFile.toPath());
        }

        // Use ByteArrayOutputStream to avoid saving the file to disk
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        
        // Create a temporary input PDF in memory
        File inputPdf = File.createTempFile("input", ".pdf");
        try (FileOutputStream fos = new FileOutputStream(inputPdf)) {
            fos.write(pdfBytes);
        }
        logger.info("Saved PDF to temporary file: {}", inputPdf.getAbsolutePath());

        // Run the OCR process and store output in memory
        String ocrMyPdfCommand = String.format("ocrmypdf --skip-text --rotate-pages --deskew --jobs 4 \"%s\" -", 
                inputPdf.getAbsolutePath());  // Use '-' to indicate output to stdout
        
        ProcessBuilder processBuilder = new ProcessBuilder("bash", "-c", ocrMyPdfCommand);
        processBuilder.inheritIO();
        processBuilder.redirectErrorStream(true);
        Process process = processBuilder.start();
        logger.info("Started ocrmypdf process");

        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                logger.info(line);
            }
        }

        // Wait for the process to finish within the timeout
        boolean finished = process.waitFor(processTimeoutSeconds, TimeUnit.SECONDS);
        if (!finished) {
            process.destroy();
            logger.error("ocrmypdf process timed out");
            return new ResponseEntity<>(HttpStatus.REQUEST_TIMEOUT);
        }
        if (process.exitValue() != 0) {
            logger.error("ocrmypdf process failed with exit code {}", process.exitValue());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }

        logger.info("ocrmypdf process completed successfully");

        // Output the processed PDF directly into the byteArrayOutputStream
        try (InputStream inputStream = process.getInputStream()) {
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                byteArrayOutputStream.write(buffer, 0, bytesRead);
            }
        }

        // Get the byte array from the ByteArrayOutputStream
        byte[] outputPdfBytes = byteArrayOutputStream.toByteArray();

        // Return the processed PDF as a ResponseEntity
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + pdfName.replace(".pdf", "_linearized.pdf"))
                .contentType(MediaType.APPLICATION_PDF)
                .body(outputPdfBytes);

    } catch (IOException | InterruptedException e) {
        logger.error("Error processing PDF: {}", pdfName, e);
        return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
